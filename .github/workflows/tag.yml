on:
  workflow_dispatch:
    inputs:
      tag_to_deploy:
        description: 'Enter the tag to deploy (e.g., tag-v1.0.0)'
        required: true
        type: string
  pull_request:
    branches:
      - main  # Trigger when a PR is targeting the 'main' branch
    types:
      - opened        # Trigger when the PR is created
      - synchronize  # Trigger when the PR is updated (e.g., new commits pushed)
      - reopened     # Trigger when a PR is reopened
      - edited      # Trigger when a PR is edited
    paths:
      - 'infra/src/dags/**'
  
concurrency:
  group: ${{ github.head_ref }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:
  check-approval:
    runs-on: ubuntu-latest
    outputs:
      approval-status: ${{ steps.check-approval.outputs.status }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Fetch PR changed files using GitHub API
        id: changed_files
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          echo "PR Number: $PR_NUMBER"
          
          if [ -z "$PR_NUMBER" ]; then
            echo "PR number not found. Exiting."
            exit 1
          fi

          CHANGED_FILES=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}/files" \
            | jq -r '.[].filename')

          echo "Changed files are:"
          echo "$CHANGED_FILES"

          SRC_CHANGED_FILES=$(echo "$CHANGED_FILES" | grep "^infra/src/dags/" || true)

          if [ -z "$SRC_CHANGED_FILES" ]; then
            echo "No files changed in path 'infra/src/dags/'. Exiting."
            exit 0
          else
            echo "Files changed in 'infra/src/dags/':"
            echo "$SRC_CHANGED_FILES"
            echo "Proceeding with further actions..."
          fi
      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      - name: Check if PR is approved
        id: check-approval
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          # Poll until PR is approved
          while true; do
            # Fetch all reviews for the PR
            pr_reviews=$(gh pr view $pr_number --json reviews --jq '.reviews')
            
            if [[ $? -ne 0 ]]; then
              echo "Failed to fetch PR details. Error: $pr_reviews"
              exit 1
            fi
            
            echo "PR Reviews: $pr_reviews"
            # If there are no reviews, print a message and wait
            if [ -z "$pr_reviews" ]; then
              echo "No reviews found yet. Waiting for reviews..."
              sleep 30  # Sleep for 30 seconds before checking again
              continue  # Continue checking without exiting
            fi
            # Check for approval status
            approval_status=$(echo "$pr_reviews" | jq '.[] | select(.state == "APPROVED")' | wc -l)
            echo "Approval status is: $approval_status"
            # If PR is approved, proceed with further steps
            if [ "$approval_status" -ge 1 ]; then
              echo "PR is approved, proceeding with further steps."

              
              break  # Exit the loop after successful merge
            else
              echo "PR is not approved yet, waiting..."
              sleep 30  # Wait for approval, check again after some time
            fi
          done

  validate_created_pr:
    needs: check-approval
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request'}}
    permissions:
      id-token: write # This is required for requesting the JWT
      contents: write  # Allow GITHUB_TOKEN to write to repository contents
      pull-requests: write  # Allow GITHUB_TOKEN to create and manage pull requests
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v3
        with:
          # token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0  # Ensure that the entire history and all tags are fetched

      - name: Fetch all tags
        run: git fetch --tags

      - name: Fetch PR description
        id: pr-description
        run: |
          
          # If triggered by a PR, fetch the PR description
          PR_NUMBER=${{ github.event.pull_request.number }}
          PR_DESCRIPTION=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" | jq -r '.body')

          # Output the PR description to the console for debugging
          echo "PR Description:"
          echo "$PR_DESCRIPTION"  # Debugging output

          # Save the PR description to a file
          echo "$PR_DESCRIPTION" > pr_description.txt
            
          # Output the saved description for debugging
          echo "PR Description saved to pr_description.txt"
          

      - name: Validate PR Description
        run: |
          # Read the PR description from the file
          PR_DESCRIPTION=$(cat pr_description.txt)

          # Debug output to see the raw PR_DESCRIPTION
          echo "Raw PR Description:"
          echo "$PR_DESCRIPTION"  # Debugging output to inspect

          # Trim leading/trailing spaces and newlines
          PR_DESCRIPTION=$(echo "$PR_DESCRIPTION" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          # Debug output to see the trimmed PR_DESCRIPTION
          echo "Trimmed PR Description:"
          echo "$PR_DESCRIPTION"  # Debugging output to inspect after trimming

          # Split into lines and print each one separately to debug line content
          echo "Printing each line separately for debugging:"
          echo "$PR_DESCRIPTION" | while IFS= read -r line; do
            echo "Line: '$line'"
          done

          check_section() {
              section_name="$1"
              line=$(echo "$PR_DESCRIPTION" | grep -A 1 "### $section_name ###" | tail -n 1)
              
              # Check if the line is empty or just spaces after the colon
              if [[ "$line" =~ ^\s*:?\s*$ ]]; then
                  echo "Error: '$section_name' section is missing or empty."
                  exit 1
              fi
          }

          # PR Description Validation
          echo "Checking PR Description..."

          # Validate each section
          check_section "Description of changes"
          check_section "Files Changed"
          check_section "Reason for Change"
          check_section "Task/Ticket/Issue"

          echo "PR Description is valid!"
      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      - name: Check Dags PR review status
        run: |
          echo "Fetching Dags PR review details..."
          pr_number="${{ github.event.pull_request.number }}"
          # Checkout the target branch (main) to prepare for merging
          git checkout main
          git pull origin main
          # Merge the PR using GitHub CLI
          gh pr merge $pr_number --merge
          echo "PR #$pr_number merged successfully into main."
##############################################################################################################
  create_tag_for_deployment:
    needs: validate_created_pr
    runs-on: ubuntu-latest
    outputs:
      NEW_TAG: ${{ steps.get_version.outputs.NEW_TAG }}
      COMMIT_MESSAGE: ${{ steps.pr_commit_message.outputs.COMMIT_MESSAGE }}
    permissions:
      id-token: write # This is required for requesting the JWT
      contents: write  # Allow GITHUB_TOKEN to write to repository contents
      pull-requests: write  # Allow GITHUB_TOKEN to create and manage pull requests
    steps:
      - name: Checkout code from PR branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }} 
          # token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Git for tagging
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
      - name: Fetch tags from remote
        run: |
          git fetch --tags
      - name: Get latest tag and determine version increment
        id: get_version
        run: |
          # Get the latest tag in the repo
          LATEST_TAG=$(git tag --list 'tag-v*' | sort -V | tail -n 1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="tag-v0.0.0"
          fi
          # Parse version components (e.g., tag-v1.0.0 -> MAJOR=1, MINOR=0, PATCH=0)
          VERSION="${LATEST_TAG//tag-v/}"
          VERSION_PARTS=(${VERSION//./ })
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]}"
          # Check commit message for version increment and modify
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)
          
          if [[ "$COMMIT_MESSAGE" == *MAJOR* ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [[ "$COMMIT_MESSAGE" == *MINOR* ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [[ "$COMMIT_MESSAGE" == *PATCH* ]]; then
            PATCH=$((PATCH + 1))
          fi
          # Set new tag
          NEW_TAG="tag-v${MAJOR}.${MINOR}.${PATCH}"
          # Ensure the tag is unique (increment PATCH if necessary)
          while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
            PATCH=$((PATCH + 1))
            NEW_TAG="tag-v${MAJOR}.${MINOR}.${PATCH}"
          done
          echo "New tag: $NEW_TAG"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Create and push tag from feature branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_TAG="${{ env.NEW_TAG }}"
          git tag $NEW_TAG
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
          git push origin $NEW_TAG
          echo "Created and pushed tag: $NEW_TAG"

      - name: Fetch PR commit message using GitHub API
        id: pr_commit_message
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          COMMIT_MESSAGE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
            | jq -r '.title + " " + .body')
          # Remove newlines and extra spaces
          COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          # Set commit message for later use
          echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_ENV
          echo "Fetched Commit Message: $COMMIT_MESSAGE"
          echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT

      - name: Fetch PR changed files using GitHub API
        id: changed_files
        run: |
          # Ensure PR number is available
          PER_PAGE=100
          PR_NUMBER="${{ github.event.pull_request.number }}"
          echo "PR Number: $PR_NUMBER"
          if [ -z "$PR_NUMBER" ]; then
            echo "PR number not found. Exiting."
            exit 1
          fi
          echo "Fetching changed files for PR #$PR_NUMBER..."

          # Fetch the changed files from the PR using GitHub API
          RESPONSE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}/files?per_page=$PER_PAGE")

          # Check if the response is empty or malformed
          if [ -z "$RESPONSE" ]; then
            echo "API response is empty. Exiting."
            exit 1
          fi

          # Extract filenames and status using jq
          CHANGED_FILES=$(echo "$RESPONSE" | jq -r '.[] | select(.status != "removed") | .filename')


          # Check if files are being returned
          if [ -z "$CHANGED_FILES" ]; then
            echo "No files found in the PR. Exiting."
            exit 1
          fi

          # Filter only files in the /src path (ignoring files outside /infra/src/dags/)
          SRC_CHANGED_FILES=$(echo "$CHANGED_FILES" | grep -E "^infra/src/dags/" || echo "")

          # Display the count of changed files
          CHANGED_FILES_COUNT=$(echo "$CHANGED_FILES" | wc -l)
          echo "all changed files count: $CHANGED_FILES_COUNT"
          SRC_CHANGED_FILES_COUNT=$(echo "$SRC_CHANGED_FILES" | wc -l)
          echo "SRC changed files count: $SRC_CHANGED_FILES_COUNT"

          # Handle the case where no files match the filter
          if [ -z "$SRC_CHANGED_FILES" ]; then
            echo "No files changed in path 'infra/src/dags/'."
            echo "Skipping further steps."
            # You can exit successfully if no relevant files are found
            exit 0
          else
            echo "Files changed in 'infra/src/dags/':"
            echo "$SRC_CHANGED_FILES"
            echo "Current working directory: $(pwd)"
            echo "$SRC_CHANGED_FILES" > dags_changed_files.txt
            echo "$CHANGED_FILES" > all_changed_files.txt
          fi
          echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT

      - name: Upload all_changed_files.txt artifact
        uses: actions/upload-artifact@v3
        with:
          name: all-changed-files
          path: all_changed_files.txt

      - name: Upload dags_changed_files.txt artifact
        uses: actions/upload-artifact@v3
        with:
          name: dags-changed-files
          path: dags_changed_files.txt
          
##############################################################################################################
  dev_changelog_pr_approve_it_manually:
    needs: [create_tag_for_deployment]
    runs-on: ubuntu-latest
    env:
        NEW_TAG: ${{ needs.create_tag_for_deployment.outputs.NEW_TAG }}
        COMMIT_MESSAGE: ${{ needs.create_tag_for_deployment.outputs.COMMIT_MESSAGE }}
    permissions:
      id-token: write # This is required for requesting the JWT
      contents: write  # Allow GITHUB_TOKEN to write to repository contents
      pull-requests: write  # Allow GITHUB_TOKEN to create and manage pull requests
    steps:
      - name: user config
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Checkout code from PR branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0  # Ensure that the entire history and all tags are fetched

      - name: Fetch all tags
        run: git fetch --tags

      - name: Download all_changed_files.txt artifact
        uses: actions/download-artifact@v3
        with:
          name: all-changed-files

      - name: Update Changelog for Dev Deployment
        env:
          GITHUB_TOKEN: ${{ secrets.PR_TOKEN }}
        run: |
          TAG_NAME="${{ env.NEW_TAG }}"
          DATE=$(date +'%Y-%m-%d')
          ENVIRONMENT="dev"
          COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"
          CHANGED_FILES_CONTENT=$(cat all_changed_files.txt)
          # Ensure we're on the main branch to update the changelog file
          git checkout main
          git pull origin main
          FEATURE_BRANCH="feature/changelog-$ENVIRONMENT-$NEW_TAG-$(date +'%Y%m%d%H%M%S')"
          git checkout -b "$FEATURE_BRANCH"
          echo "Created new feature branch: $FEATURE_BRANCH"
          # Add a changelog entry for the Dev deployment with PR commit message
          echo -e "\n#####\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n- Files Updated: $CHANGED_FILES_CONTENT" >> CHANGELOG_Dev.md
          # Commit and push changes
          git add CHANGELOG_Dev.md
          git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"
          # Push the changes
          git push origin "$FEATURE_BRANCH"
          echo "pushed changes to $FEATURE_BRANCH branch"
          echo "creating PR ...."
          # Create PR and store PR number
          pr_url=$(gh pr create \
            --title "Changelog Update ${FEATURE_BRANCH}" \
            --body "Automated PR for changelog update" \
            --base main \
            --head $FEATURE_BRANCH)
              
          echo "PR created and pending review at ${pr_url}"
          # Save the PR number for later steps
          pr_number=$(gh pr list --state=open --base main --head $FEATURE_BRANCH --json number --jq '.[0].number')
          echo "PR number: $pr_number"
          echo "changelog_pr_number=$pr_number" >> $GITHUB_ENV
          echo "changelog_pr_url=$pr_url" >> $GITHUB_ENV
          echo "dev_changelog_feature_branch=$FEATURE_BRANCH" >> $GITHUB_ENV

      - name: Get PR details
        env:
          GH_TOKEN: ${{ secrets.PR_TOKEN_GLOBAL }}
        run: |
          echo "Fetching PR details"
          pr_number="${{ env.changelog_pr_number }}"
          pr_creator=$(gh pr view $pr_number --json author --jq '.author.login')
          echo "PR number: $pr_number"
          echo "PR creator: $pr_creator"
          echo "changelog_pr_creator=$pr_creator" >> $GITHUB_ENV    

      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.PR_TOKEN_GLOBAL }}" | gh auth login --with-token
      - name: Check PR review status
        run: |
          echo "Fetching PR review details..."
          pr_number="${{ env.changelog_pr_number }}"
          FEATURE_BRANCH="${{ env.dev_changelog_feature_branch }}"
          # Poll until PR is approved
          while true; do
            # Fetch all reviews for the PR
            pr_reviews=$(gh pr view $pr_number --json reviews --jq '.reviews')
            
            if [[ $? -ne 0 ]]; then
              echo "Failed to fetch PR details. Error: $pr_reviews"
              exit 1
            fi
            
            echo "PR Reviews: $pr_reviews"
            # If there are no reviews, print a message and wait
            if [ -z "$pr_reviews" ]; then
              echo "No reviews found yet. Waiting for reviews..."
              sleep 30  # Sleep for 30 seconds before checking again
              continue  # Continue checking without exiting
            fi
            # Check for approval status
            approval_status=$(echo "$pr_reviews" | jq '.[] | select(.state == "APPROVED")' | wc -l)
            echo "Approval status is: $approval_status"
            # If PR is approved, proceed with merge
            if [ "$approval_status" -ge 1 ]; then
              echo "PR is approved, proceeding with merge."
              # Rebase and merge the PR
              git fetch origin
              git checkout main
              git pull origin main
              git checkout $FEATURE_BRANCH  # Checkout the feature branch
              git rebase main  # Rebase onto main to include any updates from other merged PRs

              # Check for conflicts after rebase
              if git ls-files -u | grep -q 'CHANGELOG_Dev.md'; then
                echo "Conflict detected in CHANGELOG_Dev.md, resolving..."
                # Resolve the conflict by accepting both changes
                git checkout --theirs CHANGELOG_Dev.md  # Accept incoming PR changes
                git checkout --ours CHANGELOG_Dev.md   # Accept current branch changes (main)
                git add CHANGELOG_Dev.md
                git commit --amend --no-edit  # Amend commit to reflect the conflict resolution
              fi

              git push origin $FEATURE_BRANCH --force-with-lease  # Push rebased branch

              # Now merge the PR using GitHub CLI
              gh pr merge $pr_number --merge --delete-branch
              echo "PR #$pr_number merged successfully into main."
              break  # Exit the loop after successful merge
            else
              echo "PR is not approved yet, waiting..."
              echo "Approve the PR , click on link to go to PR $changelog_pr_url"
              echo "Anyone can approve this PR, go to changed file section and aprpove"
              sleep 30  # Wait for approval, check again after some time
            fi
          done








#   validate_fetched_pr:
#     runs-on: ubuntu-latest
#     if: ${{ github.event_name == 'workflow_dispatch' }}
#     steps:
#       - name: Checkout the repository
#         uses: actions/checkout@v3
#         with:
#           token: ${{ secrets.PAT_TOKEN }}
#           fetch-depth: 0  # Ensure that the entire history and all tags are fetched

#       - name: Fetch all tags
#         run: git fetch --tags

#       - name: Fetch PR description
#         id: pr-description
#         run: |
#           echo "Using manual inputs"
          
#           # Capture manual inputs
#           TAG_TO_DEPLOY="${{ github.event.inputs.tag_to_deploy }}"
          
#           if [[ -n "$TAG_TO_DEPLOY" ]]; then
#             echo "Fetching PR description associated with the tag: $TAG_TO_DEPLOY"

#             # Step 1: Get the commit SHA for the tag
#             COMMIT_SHA=$(git rev-list -n 1 "$TAG_TO_DEPLOY")
#             echo "Commit SHA for tag $TAG_TO_DEPLOY: $COMMIT_SHA"
              
#             # Step 2: Use the GitHub API to find the PR associated with the commit SHA
#             RESPONSE=$(curl -s \
#               -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
#               "https://api.github.com/repos/${{ github.repository }}/pulls?state=all&per_page=100&page=1" \
#               | jq -r ".[] | select(.head.sha == \"$COMMIT_SHA\" or .merge_commit_sha == \"$COMMIT_SHA\") | .number")

#             echo "API Response for PR number: $RESPONSE"  # Debugging line to print the raw response

#             if [[ -z "$RESPONSE" ]]; then
#               echo "Error: No PR found for the given tag."
#               exit 1
#             fi
#             echo "Found PR #$RESPONSE for tag $TAG_TO_DEPLOY"
              
#             # Fetch the PR description using the PR number
#             PR_DESCRIPTION=$(curl -s \
#               -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
#               "https://api.github.com/repos/${{ github.repository }}/pulls/$RESPONSE" \
#               | jq -r '.body')

#             echo "PR Description fetched for the tag: $PR_DESCRIPTION"
            
#             # Save the PR description to a file
#             echo "$PR_DESCRIPTION" > pr_description.txt
#             echo "PR Description saved to pr_description.txt"
          
#           else
#             echo "No tag provided, skipping PR fetch."
#           fi





#       - name: Validate PR Description
#         run: |
#           # Read the PR description from the file
#           PR_DESCRIPTION=$(cat pr_description.txt)

#           # Debug output to see the raw PR_DESCRIPTION
#           echo "Raw PR Description:"
#           echo "$PR_DESCRIPTION"  # Debugging output to inspect

#           # Trim leading/trailing spaces and newlines
#           PR_DESCRIPTION=$(echo "$PR_DESCRIPTION" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

#           # Debug output to see the trimmed PR_DESCRIPTION
#           echo "Trimmed PR Description:"
#           echo "$PR_DESCRIPTION"  # Debugging output to inspect after trimming

#           # Split into lines and print each one separately to debug line content
#           echo "Printing each line separately for debugging:"
#           echo "$PR_DESCRIPTION" | while IFS= read -r line; do
#             echo "Line: '$line'"
#           done

#           check_section() {
#               section_name="$1"
#               line=$(echo "$PR_DESCRIPTION" | grep -A 1 "### $section_name ###" | tail -n 1)
              
#               # Check if the line is empty or just spaces after the colon
#               if [[ "$line" =~ ^\s*:?\s*$ ]]; then
#                   echo "Error: '$section_name' section is missing or empty."
#                   exit 1
#               fi
#           }

#           # PR Description Validation
#           echo "Checking PR Description..."

#           # Validate each section
#           check_section "Description of changes"
#           check_section "Files Changed"
#           check_section "Reason for Change"
#           check_section "Task/Ticket/Issue"

#           echo "PR Description is valid!"




# ############################################################
#   create_tag_and_deploy:
#     needs: validate_created_pr
#     if: |
#       github.event.pull_request.action == 'opened' ||
#       github.event.pull_request.action == 'reopened' ||
#       github.event.pull_request.action == 'synchronize' ||
#       github.event.pull_request.state == 'open'
#     runs-on: ubuntu-latest
#     outputs:
#       NEW_TAG: ${{ steps.get_version.outputs.NEW_TAG }}
#       COMMIT_MESSAGE: ${{ steps.pr_commit_message.outputs.COMMIT_MESSAGE }}
#     steps:
#       - name: Checkout code from PR branch
#         uses: actions/checkout@v3
#         with:
#           ref: ${{ github.head_ref }} 
#           token: ${{ secrets.PAT_TOKEN }}

#       - name: Set up Git for tagging
#         run: |
#           git config --global user.name "github-actions"
#           git config --global user.email "github-actions@github.com"

#       - name: Fetch tags from remote
#         run: |
#           git fetch --tags

#       - name: Get latest tag and determine version increment
#         id: get_version
#         run: |
#           # Get the latest tag in the repo
#           LATEST_TAG=$(git tag --list 'tag-v*' | sort -V | tail -n 1)

#           if [ -z "$LATEST_TAG" ]; then
#             LATEST_TAG="tag-v0.0.0"
#           fi

#           # Parse version components (e.g., tag-v1.0.0 -> MAJOR=1, MINOR=0, PATCH=0)
#           VERSION="${LATEST_TAG//tag-v/}"
#           VERSION_PARTS=(${VERSION//./ })
#           MAJOR="${VERSION_PARTS[0]}"
#           MINOR="${VERSION_PARTS[1]}"
#           PATCH="${VERSION_PARTS[2]}"

#           # Check commit message for version increment and modify accordingly
#           COMMIT_MESSAGE=$(git log -1 --pretty=%B)
          
#           if [[ "$COMMIT_MESSAGE" == *MAJOR* ]]; then
#             MAJOR=$((MAJOR + 1))
#             MINOR=0
#             PATCH=0
#           elif [[ "$COMMIT_MESSAGE" == *MINOR* ]]; then
#             MINOR=$((MINOR + 1))
#             PATCH=0
#           elif [[ "$COMMIT_MESSAGE" == *PATCH* ]]; then
#             PATCH=$((PATCH + 1))
#           fi

#           # Set new tag
#           NEW_TAG="tag-v${MAJOR}.${MINOR}.${PATCH}"

#           # Ensure the tag is unique (increment PATCH if necessary)
#           while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
#             PATCH=$((PATCH + 1))
#             NEW_TAG="tag-v${MAJOR}.${MINOR}.${PATCH}"
#           done

#           echo "New tag: $NEW_TAG"
#           echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV
#           echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT

#       - name: Create and push tag from feature branch
#         env:
#           GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
#         run: |
#           NEW_TAG="${{ env.NEW_TAG }}"
#           git tag $NEW_TAG
#           git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
#           git push origin $NEW_TAG
#           echo "Created and pushed tag: $NEW_TAG"

#       - name: Fetch PR commit message using GitHub API
#         id: pr_commit_message
#         run: |
#           PR_NUMBER="${{ github.event.pull_request.number }}"
#           COMMIT_MESSAGE=$(curl -s \
#             -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
#             "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
#             | jq -r '.title + " " + .body')

#           # Sanitize the commit message: Remove newlines and extra spaces
#           COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

#           # Set commit message for later use, ensuring it’s valid for the environment variable
#           echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_ENV
#           echo "Fetched Commit Message: $COMMIT_MESSAGE"
#           echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT

#       - name: Set up AWS CLI
#         uses: aws-actions/configure-aws-credentials@v1
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: us-east-1  # Update to your region


#       - name: Checkout the tag for deployment
#         run: |
#           NEW_TAG="${{ env.NEW_TAG }}"
#           git fetch --tags
#           git checkout $NEW_TAG
#           echo "Checked out tag: $NEW_TAG"
#           ls -alh  # List files to verify the tag content

#       - name: Fetch PR changed files using GitHub API
#         id: changed_files
#         run: |
#           # Ensure PR number is available
#           PR_NUMBER="${{ github.event.pull_request.number }}"
#           echo "PR Number: $PR_NUMBER"

#           if [ -z "$PR_NUMBER" ]; then
#             echo "PR number not found. Exiting."
#             exit 1
#           fi

#           echo "Fetching changed files for PR #$PR_NUMBER..."

#           # Get the changed files from the PR using GitHub API
#           CHANGED_FILES=$(curl -s \
#             -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
#             "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}/files" \
#             | jq -r '.[].filename')

#           # Filter only files in the /src path
#           SRC_CHANGED_FILES=$(echo "$CHANGED_FILES" | grep "^src/")

#           # If there are any changes in /src, print them
#           if [ -n "$SRC_CHANGED_FILES" ]; then
#             echo "Files changed in /src:"
#             echo "$SRC_CHANGED_FILES"
#             echo "Current working directory: $(pwd)"
#             echo "$SRC_CHANGED_FILES" > changed_files.txt

#           else
#             echo "No files changed in /src."
#           fi


#       - name: Deploy to Dev (Copy only changed files)
#         run: |
#           echo "Deploying to Dev environment using tag ${{ env.NEW_TAG }}"
#           echo "Current working directory: $(pwd)"
          
#           # Loop through the changed files and copy them to the S3 bucket
#           while IFS= read -r file; do
#             if [ -f "$file" ]; then
#               echo "Copying '$file' to S3..."

#               # Remove the 'src/' part from the file path if it exists
#               TARGET_FILE_PATH=$(echo "$file" | sed 's|^src/||')

#               # Copy the file to the S3 bucket without the 'src/' prefix
#               aws s3 cp "$file" "s3://githubactions-testing-bucket/dev/$TARGET_FILE_PATH"
#             else
#               echo "File $file not found."
#             fi
#           done < /home/runner/work/terracode/terracode/changed_files.txt

#   qa_deploy:
#       needs: [create_tag_and_deploy,validate_created_pr]
#       runs-on: ubuntu-latest
#       env:
#         NEW_TAG: ${{ needs.create_tag_and_deploy.outputs.NEW_TAG }}
#         COMMIT_MESSAGE: ${{ needs.create_tag_and_deploy.outputs.COMMIT_MESSAGE }}
#       steps:
#         - name: Checkout code from PR branch
#           uses: actions/checkout@v3
#           with:
#             ref: ${{ github.head_ref }} 
#             token: ${{ secrets.PAT_TOKEN }}

#         - name: Set up Git for tagging
#           run: |
#             git config --global user.name "github-actions"
#             git config --global user.email "github-actions@github.com"

#         - name: Fetch tags from remote
#           run: |
#             git fetch --tags
#             NEW_TAG="${{ env.NEW_TAG }}"
#             echo "tag is : $NEW_TAG"

#         # - name: Get latest tag and determine version increment
#         #   id: get_version
#         #   run: |
#         #     # Get the latest tag in the repo
#         #     LATEST_TAG=$(git tag --list 'tag-v*' | sort -V | tail -n 1)
#         #     echo "latest tag is : $LATEST_TAG"

#         - name: Fetch PR commit message using GitHub API
#           id: pr_commit_message
#           run: |
#             COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"
#             echo "Fetched Commit Message: $COMMIT_MESSAGE"

#       - name: Update Changelog for Dev Deployment
#         id: dev_changelog
#         run: |
#           TAG_NAME="${{ env.NEW_TAG }}"
#           DATE=$(date +'%Y-%m-%d')
#           ENVIRONMENT="dev"
#           COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"

#           # Ensure we're on the main branch to update the changelog file
#           git checkout main
#           git pull origin main

#           # Add a changelog entry for the Dev deployment with PR commit message
#           echo -e "\n#####\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n" >> CHANGELOG_Dev.md

#           # Commit and push changes
#           git add CHANGELOG_Dev.md
#           git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"

#           # Fetch and merge remote changes before pushing
#           git fetch origin main
#           git merge origin/main --no-edit --allow-unrelated-histories || true

#           # Handle conflicts manually if necessary
#           if git ls-files -u | grep -q .; then
#             echo "Merge conflicts detected, resolving..."
#             git checkout --ours .github/workflows/tag.yml  # Keep local changes in workflow
#             git checkout --ours CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md  # Keep local changes in changelog
#             git add CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md .github/workflows/tag.yml
#             git commit -m "Resolved conflicts for changelog and workflows"
#           fi

#           # Push the changes
#           git push origin HEAD:main


#       # Step 5: Auto-merge PR if deployment was successful
#       - name: Auto-merge PR
#         if: ${{ steps.dev_changelog.outcome == 'success' }}  # Only run this step if deployment was successful
#         run: |
#           # GitHub API token (created automatically in the GitHub Actions context)
#           GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"

#           # PR details
#           PR_NUMBER=${{ github.event.pull_request.number }}
#           echo $PR_NUMBER
#           REPO_OWNER=${{ github.repository_owner }}
#           echo $REPO_OWNER
#           REPO_NAME=${{ github.event.repository.name }}
#           echo $REPO_NAME


#           # PR details
#           PR_NUMBER=${{ github.event.pull_request.number }}
#           REPO_OWNER=${{ github.repository_owner }}
#           REPO_NAME=${{ github.event.repository.name }}
          
#           # Merge the PR using the GitHub API
#           echo "Merging PR #$PR_NUMBER..."
#           curl -X PUT \
#             -H "Authorization: token $GITHUB_TOKEN" \
#             -H "Accept: application/vnd.github.v3+json" \
#             -d '{"merge_method": "merge"}' \
#             "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER/merge"

   
#       # Add 'automerge' label using the GitHub CLI
#       - uses: ubuntudroid/automerge-labeler@v1
#         with:
#           token: ${{ secrets.GITHUB_TOKEN }}
#           label: 'automerge' # optional

#       - name: Automerge PR
#         id: automerge
#         uses: pascalgn/automerge-action@v0.15.6
#         env:
#           GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"


#       - name: Checkout the tag for deployment
#         run: |
#           NEW_TAG="${{ env.NEW_TAG }}"
#           git checkout --detach $NEW_TAG
#           echo "Checked out tag: $NEW_TAG"
#           ls -alh  # List files to verify the tag content

#       - name: Deploy to Qa (Copy only changed files)
#         run: |
#           echo "Deploying to Qa environment using tag ${{ env.NEW_TAG }}"
#           echo "Current working directory: $(pwd)"
          
#           # Loop through the changed files and copy them to the S3 bucket
#           while IFS= read -r file; do
#             if [ -f "$file" ]; then
#               echo "Copying '$file' to S3..."

#               # Remove the 'src/' part from the file path if it exists
#               TARGET_FILE_PATH=$(echo "$file" | sed 's|^src/||')

#               # Copy the file to the S3 bucket without the 'src/' prefix
#               aws s3 cp "$file" "s3://githubactions-testing-bucket/qa/$TARGET_FILE_PATH"
#             else
#               echo "File $file not found."
#             fi
#           done < /home/runner/work/terracode/terracode/changed_files.txt

#       - name: Update Changelog for Qa Deployment
#         run: |
#           TAG_NAME="${{ env.NEW_TAG }}"
#           DATE=$(date +'%Y-%m-%d')
#           ENVIRONMENT="qa"
#           COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"

#           # Ensure we're on the main branch to update the changelog file
#           git checkout main
#           git pull origin main

#           # Add a changelog entry for the Qa deployment with PR commit message
#           echo -e "\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n" >> CHANGELOG_Qa.md

#           # Commit and push changes
#           git add CHANGELOG_Qa.md
#           git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"

#           # Fetch and merge remote changes before pushing
#           git fetch origin main
#           git merge origin/main --no-edit --allow-unrelated-histories || true

#           # Handle conflicts manually if necessary
#           if git ls-files -u | grep -q .; then
#             echo "Merge conflicts detected, resolving..."
#             git checkout --ours .github/workflows/tag.yml  # Keep local changes in workflow
#             git checkout --ours CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md  # Keep local changes in changelog
#             git add CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md .github/workflows/tag.yml
#             git commit -m "Resolved conflicts for changelog and workflows"
#           fi

#           # Push the changes
#           git push origin HEAD:main

#       - name: Checkout the tag for deployment
#         run: |
#           NEW_TAG="${{ env.NEW_TAG }}"
#           git checkout --detach $NEW_TAG
#           echo "Checked out tag: $NEW_TAG"
#           ls -alh  # List files to verify the tag content

#       - name: Deploy to Prod (Copy only changed files)
#         run: |
#           echo "Deploying to Prod environment using tag ${{ env.NEW_TAG }}"
#           echo "Current working directory: $(pwd)"
          
#           # Loop through the changed files and copy them to the S3 bucket
#           while IFS= read -r file; do
#             if [ -f "$file" ]; then
#               echo "Copying '$file' to S3..."

#               # Remove the 'src/' part from the file path if it exists
#               TARGET_FILE_PATH=$(echo "$file" | sed 's|^src/||')

#               # Copy the file to the S3 bucket without the 'src/' prefix
#               aws s3 cp "$file" "s3://githubactions-testing-bucket/prod/$TARGET_FILE_PATH"
#             else
#               echo "File $file not found."
#             fi
#           done < /home/runner/work/terracode/terracode/changed_files.txt

#       - name: Update Changelog for Prod Deployment
#         run: |
#           TAG_NAME="${{ env.NEW_TAG }}"
#           DATE=$(date +'%Y-%m-%d')
#           ENVIRONMENT="prod"
#           COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"

#           # Ensure we're on the main branch to update the changelog file
#           git checkout main
#           git pull origin main

#           # Add a changelog entry for the Prod deployment with PR commit message
#           echo -e "\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n" >> CHANGELOG_Prod.md

#           # Commit and push changes
#           git add CHANGELOG_Prod.md
#           git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"

#           # Fetch and merge remote changes before pushing
#           git fetch origin main
#           git merge origin/main --no-edit --allow-unrelated-histories || true

#           # Handle conflicts manually if necessary
#           if git ls-files -u | grep -q .; then
#             echo "Merge conflicts detected, resolving..."
#             git checkout --ours .github/workflows/tag.yml  # Keep local changes in workflow
#             git checkout --ours CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md  # Keep local changes in changelog
#             git add CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md .github/workflows/tag.yml
#             git commit -m "Resolved conflicts for changelog and workflows"
#           fi

#           # Push the changes
#           git push origin HEAD:main


# ###########################################################

#   read_tag_and_deploy:
#     needs: validate_fetched_pr
#     if: github.event_name == 'workflow_dispatch' 
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout code from PR branch
#         uses: actions/checkout@v3
#         with:
#           ref: ${{ github.head_ref }}  # Checkout the feature branch (PR source branch)
#           token: ${{ secrets.PAT_TOKEN }}

#       - name: Set up Git for tagging
#         run: |
#           git config --global user.name "github-actions"
#           git config --global user.email "github-actions@github.com"

#       - name: Fetch tags from remote
#         run: |
#           git fetch --tags


#       - name: Fetch PR commit message using GitHub API
#         id: maunal_pr_commit_message
#         run: |
#           TAG_TO_DEPLOY="${{ github.event.inputs.tag_to_deploy }}"
          
#           # Ensure the tag variable is set correctly
#           echo "Deploying Tag: $TAG_TO_DEPLOY"

#           # Step 1: Get the commit SHA for the tag
#           COMMIT_SHA=$(git rev-list -n 1 "$TAG_TO_DEPLOY")
#           echo "Commit SHA for tag $TAG_TO_DEPLOY: $COMMIT_SHA"
              
#           # Step 2: Use the GitHub API to find the PR associated with the commit SHA
#           PR_NUMBER=$(curl -s \
#             -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
#             "https://api.github.com/repos/${{ github.repository }}/pulls?state=all&head=${COMMIT_SHA}" \
#             | jq -r '.[0].number')
          
#           # Fetch PR details
#           COMMIT_MESSAGE=$(curl -s \
#             -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
#             "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
#             | jq -r '.title + " " + .body')

#           # Sanitize the commit message: Remove newlines and extra spaces
#           COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

#           # Set commit message for later use, ensuring it’s valid for the environment variable
#           echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_ENV
#           echo "Fetched Commit Message: $COMMIT_MESSAGE"
          
#       - name: Checkout the tag for deployment
#         run: |
#           NEW_TAG="${{ github.event.inputs.tag_to_deploy }}"
#           git checkout $NEW_TAG
#           echo "Checked out tag: $NEW_TAG"
#           ls -alh  # List files to verify the tag content

#       - name: Deploy to Dev
#         run: |
#           echo "Deploying to Dev environment using tag ${{ env.NEW_TAG }}"
#           dir
#           ls
#           # Add your deployment commands for the Dev environment here.


#       - name: Update Changelog for Dev Deployment
#         run: |
#           TAG_NAME="${{ github.event.inputs.tag_to_deploy }}"
#           DATE=$(date +'%Y-%m-%d')
#           ENVIRONMENT="dev"
#           COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"

#           # Ensure we're on the main branch to update the changelog file
#           git checkout main
#           git pull origin main

#           # Debugging: Print the value of TAG_NAME to ensure it is correct
#           echo "Updating changelog for tag: $TAG_NAME"

#           # Add a changelog entry for the Dev deployment with PR commit message
#           echo -e "\n#####\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n" >> CHANGELOG_Dev.md

#           # Commit and push changes
#           git add CHANGELOG_Dev.md
#           git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"

#           # Fetch and merge remote changes before pushing
#           git fetch origin main
#           git merge origin/main --no-edit --allow-unrelated-histories || true

#           # Handle conflicts manually if necessary
#           if git ls-files -u | grep -q .; then
#             echo "Merge conflicts detected, resolving..."
#             git checkout --ours CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md  # Keep local changes in changelog
#             git add CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md
#             git commit -m "Resolved conflicts for changelog files"
#           fi

#           # Push the changes
#           git push origin HEAD:main


#       - name: Checkout the tag for deployment
#         run: |
#           NEW_TAG="${{ github.event.inputs.tag_to_deploy }}"
#           git checkout $NEW_TAG
#           echo "Checked out tag: $NEW_TAG"
#           ls -alh  # List files to verify the tag content

#       - name: Deploy to QA
#         run: |
#           echo "Deploying to QA environment using tag ${{ env.NEW_TAG }}"
#           dir
#           ls
#           # Add your deployment commands for the QA environment here.

#       - name: Update Changelog for Qa Deployment
#         run: |
#           TAG_NAME="${{ github.event.inputs.tag_to_deploy }}"
#           DATE=$(date +'%Y-%m-%d')
#           ENVIRONMENT="qa"
#           COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"

#           # Ensure we're on the main branch to update the changelog file
#           git checkout main
#           git pull origin main

#           # Debugging: Print the value of TAG_NAME to ensure it is correct
#           echo "Updating changelog for tag: $TAG_NAME"

#           # Add a changelog entry for the QA deployment with PR commit message
#           echo -e "\n#####\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n" >> CHANGELOG_Qa.md

#           # Commit and push changes
#           git add CHANGELOG_Qa.md
#           git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"

#           # Fetch and merge remote changes before pushing
#           git fetch origin main
#           git merge origin/main --no-edit --allow-unrelated-histories || true

#           # Handle conflicts manually if necessary
#           if git ls-files -u | grep -q .; then
#             echo "Merge conflicts detected, resolving..."
#             git checkout --ours CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md  # Keep local changes in changelog
#             git add CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md
#             git commit -m "Resolved conflicts for changelog files"
#           fi

#           # Push the changes
#           git push origin HEAD:main

#       - name: Checkout the tag for deployment
#         run: |
#           NEW_TAG="${{ github.event.inputs.tag_to_deploy }}"
#           git checkout $NEW_TAG
#           echo "Checked out tag: $NEW_TAG"
#           ls -alh  # List files to verify the tag content

#       - name: Deploy to PROD
#         run: |
#           echo "Deploying to PROD environment using tag ${{ env.NEW_TAG }}"
#           dir
#           ls
#           # Add your deployment commands for the PROD environment here.

#       - name: Update Changelog for Prod Deployment
#         run: |
#           TAG_NAME="${{ github.event.inputs.tag_to_deploy }}"
#           DATE=$(date +'%Y-%m-%d')
#           ENVIRONMENT="prod"
#           COMMIT_MESSAGE="${{ env.COMMIT_MESSAGE }}"

#           # Ensure we're on the main branch to update the changelog file
#           git checkout main
#           git pull origin main

#           # Debugging: Print the value of TAG_NAME to ensure it is correct
#           echo "Updating changelog for tag: $TAG_NAME"

#           # Add a changelog entry for the prod deployment with PR commit message
#           echo -e "\n#####\n## [${TAG_NAME}] - $DATE\n### Deployed to:\n- **${ENVIRONMENT}**: ${DATE}\n### Changes:\n- Deployed version ${TAG_NAME}\n- Commit Message: $COMMIT_MESSAGE\n" >> CHANGELOG_Prod.md


#           # Commit and push changes
#           git add CHANGELOG_Prod.md
#           git commit -m "Update changelog for ${TAG_NAME} deployment to ${ENVIRONMENT}"

#           # Fetch and merge remote changes before pushing
#           git fetch origin main
#           git merge origin/main --no-edit --allow-unrelated-histories || true

#           # Handle conflicts manually if necessary
#           if git ls-files -u | grep -q .; then
#             echo "Merge conflicts detected, resolving..."
#             git checkout --ours CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md  # Keep local changes in changelog
#             git add CHANGELOG_Dev.md CHANGELOG_Qa.md CHANGELOG_Prod.md
#             git commit -m "Resolved conflicts for changelog files"
#           fi

#           # Push the changes
#           git push origin HEAD:main